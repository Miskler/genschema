# json2schema2schema

# Идея

Есть глобальный менеджер который агрегирует кандидатов и проводит рекурсивную обработку.

Обработка идет следующим образом: снизу вверх идет обход всех схем/json, они в порядке приоритета предоставляются
на обратку компараторам, которые проводят необходимые операции и отдают слой (они все не видят схему глобально, работают лишь со своим слоем).

Правила глобальные задают:
Приоритет и список компараторов

Дальше компараторы по приоритету получают сначало вопрос: "ты будешь что-то обрабатывать?".
Если ответ положительный - они могут вернуть список компараторов, которым в дальнейшем НЕЛЬЗЯ обрабатывать этот слой.
Дальше если был положительный ответ - вызывается функция обработки слоя. Функции компаратора всегда передуют:
1. list объект-ресурса кандидатов-схем
2. list объект-ресурса кандидатов-json
3. результат обработки прошлых слоев (если нет то {})
4. env-путь (например property/anyOf/pattern/property)
Оба списка уже распарсены до нужного уровня вложенности

Объект ресурс имеет:
content, id, type=json/schema

Функция возвращает:
Результат ее обработки словарь (или none), результат ее обработки массив словарей (или none)
ЕСЛИ есть Of атрибуты (any,all,one) то в них всегда проставляется технический атрибут `"j2sElementTrigger"=[объект-ресурса.id]`
Этот атрибут говорит о том, какие данные послужили триггером для создания этого ветвления.

Глобальный словарь просто заменяет текущий уровень на другой, а массив сигнализирует о двойственности данных и заставляет
основной обработчик добавить one/all/any of в зависимости от конфигурации (если компаратор обрабатывал элемент of атрибута - то исходный
элемент удаляется и появляются несколько новых от вернувшегося значения)

Например:
```py
converter.add_schema({ # id=0
    "type": "object",
    "properties": {
        "name": {"type": "integer"}
    }
})
converter.add_schema({ # id=1
    "type": "object",
    "properties": {
        "name": {"type": "string"}
    }
})
converter.add_json({"name": "Bob"}) # id=2
```
Тогда когда отработает TypeCompare он укажет:
```json
{
    "type": "object",
    "properties": {
        "name": {
            "anyOf": [
                {"type": "string",
                 "j2sElementTrigger": [1, 2]},
                {"type": "integer",
                 "j2sElementTrigger": [0]}
            ]
        }
    }
}
```
Возврат компаратора при этом будет выглядеть как:
```py
None, [{"type": "string", "j2sElementTrigger": [1, 2]}, {"type": "integer", "j2sElementTrigger": [0]}]
```

Следующий компаратор будет отдельно обрабатывать уровень глобальный переменной и каждый в Of атрибутах. Он кстати проходится не только по anyOf, но еще и по oneOf, allOf. То есть если нужно прописать атрибут 0 и 1 то он их продублирует в оба места, а если атрибут нужен 2 то он автомачиски дается и 1 (так как в одной группе).
Либо, если 1 и 2 противоречят, то он опять их раздвоит и продублирует атрибуты существующие в оба места, а дальше добавит свои.

Например если дальше идет format, то может быть:
```json
{
    "type": "object",
    "properties": {
        "name": {
            "anyOf": [
                {"type": "string",
                 "j2sElementTrigger": [1]},
                {"type": "string",
                 "format": "email",
                 "j2sElementTrigger": [2]},
                {"type": "integer",
                 "j2sElementTrigger": [0]}
            ]
        }
    }
}
```
Ответ компаратора при этом будет:
```py
None, [{"type": "string", "j2sElementTrigger": [1]}, {"type": "integer", "format": "email", "j2sElementTrigger": [2]}]
{"type": "integer", "j2sElementTrigger": [0]}, None
```

После того как все компараторы отработают, код переходит на следующий уровень через properties и items[*], в том числе и в Of где применимо (type=array|object)
